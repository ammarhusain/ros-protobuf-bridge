#!/usr/bin/env python

import sys
import ntpath
import os
import re
import hashlib

try:
    from cStringIO import StringIO  # Python 2.x
except ImportError:
    from io import StringIO  # Python 3.x

def Out(s, str):
    s.write("%s\n"%str)

def WriteChecksumTrait(s, pkg_name, class_name):
    checksum = hashlib.md5("%s::%s" %(pkg_name, class_name)).hexdigest()
    cpp = """
    template <>
    struct MD5Sum<@Package@::@Class@> {
    static const char* value(@Package@::@Class@ const& o) {
      return "@Checksum@";
    }
    static const char* value() {
      return "@Checksum@";
    }
    };
    """
    cpp = cpp.replace("@Checksum@", checksum)
    cpp = cpp.replace("@Class@", class_name)
    cpp = cpp.replace("@Package@", pkg_name)
    s.write(cpp)

def WriteDataTypeTrait(s, pkg_name, class_name):
    cpp = """
    template <>
    struct DataType<@Package@::@Class@> {
    static const char* value(@Package@::@Class@ const& o) {
      return "@Package@/@Class@";
    }
    static const char* value() {
      return "@Package@/@Class@";
    }
    };
    """
    cpp = cpp.replace("@Class@", class_name)
    cpp = cpp.replace("@Package@", pkg_name)
    s.write(cpp)

def WriteDefinitionTrait(s, pkg_name, class_name):
    cpp = """
    template <>
    struct Definition<@Package@::@Class@> {
    static const char* value(@Package@::@Class@ const& o) {
      return "Protobuf generated msg for @Package@::@Class@";
    }
    static const char* value() {
      return "Protobuf generated msg for @Package@::@Class@";
    }
    };
    """
    cpp = cpp.replace("@Class@", class_name)
    cpp = cpp.replace("@Package@", pkg_name)
    s.write(cpp)

def WriteSerializationTrait(s, pkg_name, class_name):
    cpp = """
    namespace serialization {
    template <>
    struct Serializer<@Package@::@Class@> {
    template <typename Stream>
    inline static void write(Stream& stream, @Package@::@Class@ const& o) {
      std::string ser_bytes;
      if (!o.SerializeToString(&ser_bytes)) {
        std::cerr << "Serialization failed." << std::endl;
        return;
      }
      memcpy(stream.advance(ser_bytes.size()), ser_bytes.c_str(), ser_bytes.size());
    }

    template <typename Stream>
    inline static void read(Stream &stream, @Package@::@Class@ &o) {
      std::string deser_bytes;
      deser_bytes.resize(stream.getLength());
      memcpy(&deser_bytes[0], stream.advance(stream.getLength()),
             stream.getLength());
      if (!o.ParseFromString(deser_bytes)) {
        std::cerr << "Deserialization failed." << std::endl;
        return;
      }
    }

    inline static uint32_t
    serializedLength(@Package@::@Class@ const &o) {
      return o.ByteSizeLong();
    }
    };
    }  // namespace serialization
    """
    cpp = cpp.replace("@Class@", class_name)
    cpp = cpp.replace("@Package@", pkg_name)
    s.write(cpp)

def WriteClassTraits(s, pkg_name, class_name):
    Out(s,"namespace message_traits {\n")
    WriteChecksumTrait(s, pkg_name, class_name)
    WriteDataTypeTrait(s, pkg_name, class_name)
    WriteDefinitionTrait(s, pkg_name, class_name)
    Out(s,"}  // namespace message_traits")
    WriteSerializationTrait(s, pkg_name, class_name)

def GenerateCppHeader(proto_file_name, pkg_name, class_names):
    """
    Umbrella function that generates the entire header implementing ROS msg traits
    :return:
    """
    s = StringIO()

    cpp = """
    /// @author    Auto-generated by ProtobufROSmsgBOT
    ///
    /// @warning  This file has been autogenerated by the build process.
    ///           Do not modify this file.

    #pragma once

    #include <@PROTO_H@.pb.h>
    #include <ros/message_traits.h>
    #include <ros/serialization.h>

    namespace ros {
    """
    cpp = cpp.replace("@PROTO_H@", format(proto_file_name))
    s.write(cpp)

    for c in class_names:
        WriteClassTraits(s, pkg_name, c)
    Out(s,"}  // namespace ros")
    # write code-gen only if different from build artifact
    header_file_name = 'proto_ros/cpp/%s/%s.ros.h' %(pkg_name, proto_file_name)
    is_diff = True
    # write out the generated header in the pkg_name directory for include namespacing
    if not os.path.exists('proto_ros/cpp/%s'%pkg_name):
        os.makedirs('proto_ros/cpp/%s'%pkg_name)
    if os.path.isfile(header_file_name):
        with open(header_file_name, 'r') as f:
            is_diff = f.read() != s.getvalue()
    if is_diff:
        with open(header_file_name, 'w') as f:
            f.write(s.getvalue())
    s.close()
